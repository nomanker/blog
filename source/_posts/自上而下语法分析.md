---
title: 自上而下语法分析
date: 2021-05-05 19:31:39
categories:
  - 学习之路
tags: 
- 编译器
---

### 1.引言

**编译程序的核心部分**

**语法分析的任务**：识别由词法分析得出的单词序列是否是给定文法的句子

**语法分析的理论基础**：

* 上下文无关文法
* 下推自动机

**语法分析方式**：

* 自上而下语法分析
  * 反复使用不同产生式进行推导以谋求与输入符号串相匹配
* 自下而上语法分析
  * 对输入符号串寻找不同产生式进行规约直到文法开始符号

注：这里所说的输入符号指词法分析所识别的单词

***

### 2.下推自动机(PDA)

#### 2.1 下推自动机模型

![image-20210216115703268](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210216115703268.png)

注：

1. PDA和FA的模型相比，多了一个下推栈

2. PDA的动作由三个因素决定：当前状态、读头所指向符号、下推栈栈顶符号

3. 一个输入串能被PDA所接受，仅当输入串读完，下推栈变空；或输入串读完，控制器到达某些终态
4. 正规文法和有限自动机仅适合于描述和识别高级语言的各类单词，语句可用上下文无关文法来描述，而下推自动机又恰好识别上下文无关文法所能描述的语言，因此**上下文无关文法及其对应的下推自动机就成为编译技术中语法分析的理论基础**

#### 2.2 下推自动机的形式定义

##### 2.2.1 定义

![image-20210216120600007](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210216120600007.png)

![image-20210216120726217](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210216120726217.png)

注：

1. 由此定义的PDA肯定是不确定的PDA。具有**不确定性**，我们在构造PDA M算法时要对PDA做一些限制
2. ![image-20210216121000311](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210216121000311.png)
3. 输入串能为PDA所接受，仅当输入串读完，下推栈为空；或者输入串读完，控制器到达某些终态
4. 下推自动机还配置输出带，以记录推导或规约过程所用的产生式编号
5. 对于形如A->ω的产生式，有δ(q,ε,A)=(q,ω)，这称为**推导**
6. δ(q,a,a)=(q,ε)称为**匹配**，其中a∈Σ

- ![image-20210216122210422](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210216122210422.png)

- ![image-20210216122406681](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210216122406681.png)

***

### 3.自上而下分析法的一般问题

* 自上而下语法分析定义

  * 从文法的开始符号开始，反复使用不同产生式进行推导以谋求与输入符号串相匹配

  注：此处的输入符号串是指词法分析结果的一串二元式


#### 3.1 一般方法

  * 试探法：带回溯的自上而下分析法

  * 基本构成

    设下推栈的初始状态包含两个符号:"#S",其中#为栈底，S为文法开始符号。整个分析过程在语法分析程序控制下进行。在语法分析中用到的文法产生式的表，成为**语法表**。

![image-20210218151134684](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210218151134684.png)

* 算法
  * 若栈顶符号x是非终结符，查询语法表，找出一个以x作为左部的产生式，x出栈，并将其右部反序入栈，且输出带记下产生式编号——推导
  * 若栈顶符号x是终结符，且读头下的符号也是x，则x出栈，读头指向下一个符号——匹配
  * 若栈顶符号x是终结符，但读头下的符号不是x，则匹配失败。这说明可能前面推导时选错了候选式，退回到上次推到现场(包括栈顶符号、读头的指针和输出带上信息)——回溯
  * 回溯后选取另一候选式进行推导，若没有候选式可选，则进一步回溯。若回溯到开始符号时已无候选式可选，则识别失败
  * 若栈内仅剩下#，且读头也指向#，则识别成功
* 带回溯的自上而下分析法的缺陷
  * 如果文法存在**左递归**，语法分析会无限循环下去
  * 若产生式存在多个候选式，选择哪个进行推导完全是盲目的
  * 回溯会引起**时间和空间的大量消耗**
  * 如果被识别的语句是错的，算法**无法指出错误的确切位置**

#### 3.2 不带回溯的自上而下分析算法

* 消除左递归

  * 什么是左递归
    * 直接左递归   P->Pa
    * 间接左递归   P->Aa, A->Pb
  * 消除左递归
    * 消除直接左递归
    * 消除间接左递归

* 消除直接左递归(将左递归转化为右递归)

  ![image-20210218154007176](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210218154007176.png)

![image-20210218154226525](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210218154226525.png)

注：只有最左边的P参加变换

* **消除左递归算法**

  * 把文法G的所有非终结符按任意顺序排列成P1,P2,P3...,然后按此顺序执行步骤2
  * ![image-20210219170617797](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210219170617797.png)
  * 删去**从文法开始符号不可达**的非终结符产生式

  注:

  1. 此算法适用于消除不含形如P->P的产生式，也不含以ε为右部的产生式的文法
  2. 第二步所做的工作是：
     1. 若产生式出现直接左递归则用消除直接左递归的方法消除掉
     2. 若产生式右部最左符号是非终结符且其序号大于左部的非终结符，则不处理
     3. 若序号小于左部的非终结符，则将这序号小的非终结符用其右部串来取代，然后消除新的直接左递归

  ![image-20210219172033566](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210219172033566.png)

![image-20210219172213947](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210219172213947.png)

注：

1. 若非终结符排列顺序不同，改写后的文法也不同，但他们是等价的
2. 开始符号不能改变



* 消除回溯

1. 产生回溯的原因

   进行推导时，若产生式存在多个候选式，选择哪个候选式进行推导存在不确定性

2. 消除回溯的基本原则

   对文法的任何非终结符，若能根据当前读头下的符号，准确的选择一个候选式进行推导，那么回溯就可以消除

   注：之所以会产生回溯是因为在推导匹配的过程中存在**虚假匹配**(匹配后得到的结果是错误的)

3. 消除回溯的方法

   预测与提左因子

4. **预测**

   根据读头下符号选择候选式，使其**第一个符号**与读头下符号相同，或**该候选式可推导出的第一个符号**与读头下符号相同。相当于向前看一个符号，所以称为预测

   注：使用了预测之后，选择候选式不再是盲目的了，所以也就无需回溯

5. 求候选式的**终结首符集**

   令G是一个不含左递归的文法，对G的所有非终结符的各候选式α，可求出它的终结首符First(α)
   
   ![image-20210220141819733](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210220141819733.png)
   
   设A是非终结符，且A->α|β，当A出现在下推栈的栈顶，且输入符号为a时，应如何选择A的候选式进行推导。可以分为四种情况：
   
   1. 若a∈First(α)，而a∉First(β),则选A->α
   2. 若a∉First(α)，而a∈First(β),则选A->β
   3. 若a∉First(α)，而a∉First(β)，则表示输入有错
   4. 若a∈First(α)，而a∈First(β)，则表示终结首符集相交，需改写文法，进行公因子提取
   
6. 采用预测方法后PDA的运行

   * 设A为出现在栈顶的非终结符，如果A的所有候选式的候选首符集都两两不相交，那么，PDA可以根据它所面临的读头符号，准确的指派某候选式替换A
   * 许多文法都存在一些非终结符，其所有候选的首符集并不是两两不相交，因此仍然无法选择用哪个候选式进行推导

7. **提取公共左因子**

   ![image-20210220143336800](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210220143336800.png)

   注：

   1. 通过反复提取左因子，就能把所有非终结符的所有候选首符集变为两两不相交
   2. 反复提取左因子也有一定代价，因为在提取过程中会**大量引入非终结符和ε产生式**，增加语法分析的复杂性

***

### 4.预测分析程序与LL(1)文法

#### 4.1 预测分析程序

1. 带预测分析的PDA

   在PDA中加入预测分析后，可以消除自上而下分析中出现回溯的现象。此时PDA可以改造为：

   ![image-20210220143845569](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210220143845569.png)

   注：

   1. 整个过程都在预测分析程序控制下工作
   2. 预测分析程序使用一张预测分析表，它是预测分析程序分析时的主要依据

2. 预测分析表

   预测分析表是一矩阵M[A,a]，其中**行标A是非终结符**，**列标a是终结符或串终结符**；矩阵元素M[A.a]是存放A的一个候选式，指出当前栈顶符号为A且面临读入符号为a时应选的**候选式**；或者存放**出错标志**，指出A不该面临读入符号a。

3. 预测分析程序算法描述

   设栈顶符号为X，读入符号为a,则

   1. 若X=a='#'，则表示识别成功(**栈空**)，退出分析程序
   2. 若X=a!='#'，则表示匹配，弹出栈顶符号X，读头前进一格，让读头指向下一个符号，以读入下一个符号；若X是终结符，但X!=a，则调用error处理
   3. 若X为**非终结符**，则查预测分析表M。若M[X,a]中存放着关于X的产生式，则弹出X，且将相应产生式右部以**自右向左**的顺序压入栈，在输出带上记下产生式编号；若M[X,a]中存放着出错标记，则调用相应error处理

#### 4.2 求串α的终结首符集和非终结首符A的随符集

1. 求串α的终结首符集First(α)

   1. 定义

      ![image-20210220145913908](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210220145913908.png)

   2. 算法

      ![image-20210220145948226](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210220145948226.png)

      1. 求出文法中每个文法符号的首符集

         ![image-20210220165137821](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210220165137821.png)

      ![image-20210220165151823](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210220165151823.png)

       2. 求First(α)

          ![image-20210220165731660](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210220165731660.png)
          
          例子:
          
          ![image-20210221211322403](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210221211322403.png)
          
       3. 求非终结符A的随符集Follow(A)

           1. 定义

              ![image-20210221170358929](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210221170358929.png)

              注：

              1. 若S->…A，则规定：#属于Follow(A)
              2. Follow(A)集合是指在所有句型中紧跟A之后的终结符或#所组成的集合

           2. 算法

              ![image-20210221170735993](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210221170735993.png)

              注：这里的文法必须是**消除了左递归**且**提取了左因子**之后的文法

           3. 理解求解规则

              ![image-20210221211745888](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210221211745888.png)

              

#### 4.3 构造预测分析表

1. 基本思想

   ![image-20210221171947996](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210221171947996.png)

2. 构造算法

   ![image-20210221172201385](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210221172201385.png)

   注：

   1. 用此算法可以为任意文法G构造其分析表M
   2. 若是二义文法或没有消除左递归和提取左因子的文法，构造出的M包含有**重定义项**。即，它们的M[A,a]中填有一个以上的产生式

#### 4.4 LL(1)文法

1. 定义

   若文法G的预测分析表M中不含有多重定义项，则称G为LL(1)文法

   注:

   1. LL(1)文法无二义
   2. LL的含义是从左到右扫描输入串，采用最左推导分析句子
   3. 数字1表示分析句子时需向前看一个输入符号
   4. 有LL(1)就有LL(K),LL(k)向前查看k个输入符号，选择候选式更加准确，但M的尺寸会以n的k次方增长，其中n=|Σ|+1,。对于程序设计语言取k=1就够了

2. 证明定理

   ![image-20210221173356632](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210221173356632.png)

   注：

   1. 可以使用这个定理直接根据首符集、随符集来判断文法是否是LL(1)。但是在判断之前，必须消除左递归和提取公共左因子，因为包含左递归和公共左因子的文法肯定不是LL(1)文法
   2. LL(1)文法只是上下文无关文法的一个子集

4.5 状态表

1. 为了**节省空间并提高算法的效率**，可以对预测分析表进行简化。不需把整个产生式放在分析表的各项中，只需要将右部候选式**倒序存放其中**，甚至在分析表中只保存产生式编号，产生式另存在一个语法表中。

   注：

   1. 将右部候选式倒序存放在分析表中是为了替换的时候可以边读边压栈
   2. 一般情况下，分析表是稀疏矩阵，即使改为仅填编号，空间浪费也很大，因此需要改进，引入状态表概念。

   **有待继续学习！！！**

***

### 5.递归下降分析法

#### 5.1 递归下降分析程序

		若一个文法G不含有左递归，而且每个非终结符的所有候选式的首符集都是两两不相交的，那么就能为G中每个非终结符编写一个相应的递归过程。把该文法中所有这样的递归过程组合起来就可能构成一个不带回溯的自上而下分析程序——**递归下降分析程序**

#### 5.2 递归下降分析法实现思想

		为文法中每个非终结符编写一个递归过程，每个过程的功能是识别该非终结符推出的串，当某非终结符的产生式有多个候选式时，按LL(1)形式唯一确定选择哪个候选式进行推导，若遇到某候选式为ε，认为其自动匹配。把这些递归过程组合起来就构成了文法的递归下降分析程序

#### 5.3 递归下降分析法的实现

1. **使用LL(1)文法**

   现将文法消除左递归、提取公共左因子，使之成为LL(1)文法，后将每个非终结符对应一个递归过程，过程体是按照响应产生式的右部符号串顺序编写。每匹配一个终结符，则再读入下一个符号，对产生式右边的每个非终结符，则调用相应的过程

   注：使用递归实际上与下推栈的原理相同

2. 使用**BNF范式**

   先将文法改写为BNF范式，后再书写递归子程序

#### 5.4 递归下降分析法的缺点

1. 对文法的要求高，必须满足LL(1)文法
2. 高深度的递归调用会影响语法分析的效率，速度慢，占空间多