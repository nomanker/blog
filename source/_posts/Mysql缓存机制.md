---
title: Mysql缓存机制
categories:
  - 学习之路
date: 2021-05-07 18:22:36
tags:
- Mysql
---

MySQL缓存机制是缓存sql文本以及结果保存到服务器内存中，如果运行相同的Sql，服务器直接从缓存中获取结果，无需再去解析、优化、执行sql。如果这个表修改了，那么使用这个表中所有的缓存将不再有效，查询缓存值的相关条目将被清空。表中的改变是指表中任何数据或者结构的改变，显然，对于频繁更新的表，查询缓存不合适，对于一些不变的数据且有大量相同sql查询的表，查询缓存会节省很大的性能。

#### 命中条件

缓存存在一个hash表中，将查询sql、数据库、客户端协议等作为key，在判断命中前，MySQL不会解析sql，而是使用sql去查询缓存，sql上的任何字符的不同，如空格、注释都会导致缓存不命中。**通常使用统一编码规则是一个好习惯，会让系统运行的更快**

如果查询有不确定的数据like now()等，查询完成后的结果则不会被缓存，包含不确定的数是不会放置到缓存中的。"如果查询中包括一个不确定的函数，MySQL则不会检查查询缓存"，这句话是不正确的，因为在检查查询缓存的时候，还没有解析sql语句，所以MySQL并不知道查询语句中是否包含这类函数。在从检查查询缓存之前，MySQL只做一件事，就是通过一件事，就是通过一个大小写不敏感的检查查看SQL语句是否已sel开头。

准确的说法应该是：**如果查询语句中包含任何的不确定函数，那么在查询缓存中是不可能找到缓存结果的。因为即使之前刚刚执行了这样的查询，结果也不会放在查询缓存中。MySQL只要发现不能被缓存的部分，就会禁止这个查询被缓存。**

如果查询缓存使用了很大量的内存，缓存失效操作就可能成为一个非常严重的问题瓶颈。如果缓存中存放了大量的查询结果，那么缓存失效时，整个系统可能都会僵死一会。因为这个操作是靠一个全局锁操作保护的，所有需要做该操作的查询都需要等待这个锁，而且无论是检测是否命中缓存、还是缓存失效检测都需要等待这个全局锁。

#### 工作流程

1. 服务器接收sql，以sql和一些其他条件作为key去查找缓存表
2. 如果找到了缓存，则直接返回缓存
3. 如果没有找到缓存，则执行sql查询，包括原来的sql解析、优化等
4. 执行完sql后，将sql查询结果缓存入缓存表中

#### 缓存失败

当某个表正在写入数据，则这个表的缓存(命中缓存、缓存写入等)将会处于失效状态，在Innodb中，如果某个事务修改了这张表，则这个表的缓存在事务提交之前都会处于失效状态，在这个事物提交之前，这个表的相关查询都无法被缓存

#### 缓存的内存管理

缓存会在内存中开辟一块内存（query_cache_size）来维护缓存数据，其中大概有40K的空间是用来维护缓存数据的元数据的，例如空间内存，例如空间内存，数据表和查询结果映射，SQL和查询结果映射的。
mysql将这个大内存块分为小内存块（query_cache_min_res_unit),每个小块中存储自身的类型、大小和查询结果数据，还有前后内存块的指针。
mysql需要设置单个小存储块大小，在SQL查询开始（还未得到结果）时就去申请一块内存空间，所以即使你的缓存数据没有达到这个大小也需要这个大小的数据块去保存（like linux filesystem’s block)。如果超出这个内存块的大小，则需要再申请一个内存块。当查询完成发现申请的内存有富余，则会将富余的内存空间是放点，这就会造成内存碎片的问题，见下图
![这里写图片描述](https://img-blog.csdn.net/20180523115141205?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F6cWFuemM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 缓存的使用时机

衡量打开缓存是否对系统有性能提升是一个很难的话题

1. 通过缓存命中率判断, 缓存命中率 = 缓存命中次数 (Qcache_hits) / 查询次数 (Com_select)
2. 通过缓存写入率, 写入率 = 缓存写入次数 (Qcache_inserts) / 查询次数 (Qcache_inserts)
3. 通过 命中-写入率 判断, 比率 = 命中次数 (Qcache_hits) / 写入次数 (Qcache_inserts), 高性能MySQL中称之为比较能反映性能提升的指数,一般来说达到3:1则算是查询缓存有效,而最好能够达到10:1

#### 查询缓存如何使用内存

查询缓存使完全存储在内存中的，所以在配置和使用它之前，我们需要了解它是如何使用内存的。除了查询结果之外，需要缓存的还有很多别的维护相关的数据。这和文件系统有些类似：需要一些内存专门用来确定哪些内存目前是可用的、哪些是已经用掉的、哪些用来存储数据表和查询结果之前的映射、哪些用来存储查询字符串和查询结果。

这些基本的管理维护数据结构大概需要40kb的内存资源，除此之外，MySQL用于查询缓存的内存被分成一个个的数据块，数据块是变长的。每一个数据块中，存储了自己的类型、大小和存储的数据本身，还外加指向前一个和后一个数据块的指针。数据块的类型有：存储查询结果、存储查询和数据表的映射、存储查询文本等。不同的存储块，在内存使用上没有什么不同，从用户角度来看无需区分他们。

当服务器启动的时候，它先初始化查询缓存需要的内存。这个内存池初始是一个完整的空闲块。这个空闲块的大小就是你锁配置的查询缓存大小减去用于维护原数据的数据结构所消耗的空间。

当有查询结果需要缓存的时候，MySQL先从大的空间块中申请一个数据块用于存储结果。这个数据块需要大于参数query_cache_min_res_unit的配置，即使查询结果远远小于此，也需要至少申请query_cache_min_res_unit空间。因为需要在查询开始返回结果的时候就分配空间，而此时是无法预知查询结果到底多大的，所以MySQL无法为每一个结果精确分配大小恰好的缓存空间。

因为需要先锁住空间块，然后找到合适大小数据库，所以相对来说，分配内存块是一个非常慢的操作。MySQL尽量避免这个操作的次数。当需要缓存一个查询结果的时候，它先选择一个尽可能小的内存块，然后将结果存入其中。如果数据块全部用完，但仍有剩余数据需要存储，那么MySQL会申请一块新的数据块；仍然是尽可能小的数据块，继续存储结果数据。当查询完成时，如果申请的内存空间还有剩余，MySQL会将其释放，并放入空闲内存部分。

![image-20210410104212101](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210410104212101.png)

我们上面说的分配内存块，并不是指通过函数malloc()向操作系统申请内存，这个操作只是初次创建查询缓存的时候执行一次。这里分配内存块是指在空闲块列表中找到一个合适的内存块，或者从正在使用的、待淘汰的内存块中回收在使用。也就是说，这里MySQL自己管理一大块内存，而不依赖操作系统的内存管理。

至此一切看起来都很简单。不过实际情况很复杂。例如，我们假设平均查询结果非常小，服务器在并发的想不通的两个链接返回结果，返回结果后MySQL回收剩余数据块空间时会发现，回收的数据块小于query_cache_min_res_unit，所以不能够直接在后续的内存块分配中使用。那么分配就更复杂一些。

![image-20210410104221333](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210410104221333.png)

在收缩第一个查询结果使用的缓存空间时，就会在第二个查询结果之间留下一个空隙，因为小于query_cache_min_res_unit而不能再次被查询缓存使用。这类空隙就成为了内存空间碎片，这在内存管理、文件系统管理上都是经典问题。有很多种情况都会导致碎片，例如缓存失效时，可能导致留下太小的数据块无法在后续缓存中使用。