---
title: C++代码内存消耗
categories:
  - 学习之路
date: 2021-05-09 22:03:44
tags:
---

### 1.不同语言的内存管理

* C/C++需要由coder自己管理堆内存的申请和释放
* Java靠JVM进行内存管理，了解JVM内存管理的机制能够避免因为一些错误的代码而导致的内存泄漏或内存溢出
* Python中的内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。只有解释器拥有访问堆的权限。
* Rust与其他编程语言相比，最大亮点就是引入了一套在编译期间，通过静态分析的方式，确定所有对象的作用域与生命周期，从而可以精确的在某个对象不再被使用时，将其销毁，并且不引入任何RT复杂度。

现代编程语言，对于堆上分配的内存（可以理解为malloc出来的内存）进行管理，大致有这两种方式：

1. 使用者在代码中显式地调用函数，回收这部分内存，如：C++，C
2. 引入自动地垃圾回收机制，在运行时由程序自动管理，如：Java，Python

前者地问题是给代码编写者引入了额外的工作，很难避免bug；后者的问题是会降低程序的性能，尤其是对于实时性要求比较高的程序。

***

### 2.C++的内存管理

程序运行时所需的内存空间分为固定部分以及可变部分，如下：

![image-20210509211658720](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210509211658720.png)

固定部分的内存消耗不会随着程序的运行而产生变化，可变部分则会根据程序的运行情况进行变化。

一个C/C++程序运行时所占用的内存分为以下几个部分：

* Stack：由编译器自动分配释放，存放函数的参数值，局部变量值，其操作方式类似于栈。
* Heap：一般情况下由coder分配释放，若不释放，则在程序结束时可能会由OS进行回收。
* Uninitialized Data：存放未初始化的全局变量和静态变量。
* Initialized Data：存放已初始化的全局变量和静态变量。
* Text（程序代码区）：存放函数体的二进制代码

代码区和数据区所占的空间都是固定的，而且占用的空间非常小，因此运行时消耗的内存主要看可变部分。

在可变部分中，Stack中的数据在代码块执行结束后，系统会自动回收，而Heap中的数据是需要coder自己回收，如若处理不当，便会造成**内存泄漏**。

而Java，Python则不需要coder去考虑内存泄漏的问题，interpreter和Jvm把这些事情都做了。

***

### 3.内存泄露和内存溢出

**内存泄漏**（memory leak）：程序在申请内存后，无法释放已申请的内存空间，结果那块内存自己也没有办法访问（可能是把它的地址弄丢了），而系统也不能再次将它分配给需要的程序。内存泄漏堆积后果很严重，==无论多少内存，迟早被占用光==！

以发生的方式可以分为4类：

1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行到的时候都会导致一块内存泄漏。
2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块且仅一块内存发生泄漏。比如，在类的构造函数中分配内存，而在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。
4. 隐式内存泄漏。程序在运行过程中不停地分配内存，但是直到程序结束时才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。

从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到。

内存泄露最终会导致内存溢出（out of memory）

**内存溢出**（out of memory）：程序在申请内存时，没有足够的内存空间供其使用，比如申请了一个integer，但是给它存了long才能存下的数，那就是内存溢出。

内存溢出的原因：

1. 内存中加载的数据量过于庞大，如一次从数据库中取出过多数据。
2. 集合中有对于对象的引用，使用完后未情况。
3. 代码中存在死循环或循环产生过多重复的对象实体。
4. 第三方软件中的bug。

之后再单独开一篇好好学习下内存泄漏方面的问题……

***

### 4.如何计算程序占用多大的内存

![image-20210509215049129](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210509215049129.png)

注意图中有两个不一样的地方，为什么64位的指针就占用了8个字节，而32位的指针占用4个字节呢？

1个字节占8个比特，那么4个字节就是32个比特，可存放数据的大小为2^32，也就是4G空间的大小，即：可以寻找4G空间大小的内存地址。

大家现在使用的计算机一般都是64位了，所以编译器也都是64位的。

安装64位的操作系统的计算机内存都已经超过了4G，也就是指针大小如果还是4个字节的话，就已经不能寻址全部的内存地址，所以64位编译器使用8个字节的指针才能寻找所有的内存地址。

注意2^64是一个非常巨大的数，对于寻找地址来说已经足够用了。

***

### 5.内存对齐

可以跨平台的编程语言都需要进行**内存对齐**。

内存对齐的原因：

1. 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。
2. 硬件原因：经过内存对齐后，CPU访问内存的速度大大提升。

内存对齐和非内存对齐的产生的效果区别：

CPU读取内存不是一次读取单个字节，而是一块一块来读取内存，块的大小可以是2，4，8，16个字节，具体情况取决于硬件。

假设CPU把内存划分成4字节大小的块，要读取一个4字节大小的int型数据，来看一下这两种情况下CPU的工作量：

第一种为内存对齐的情况

![image-20210509215644431](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210509215644431.png)

一字节的char占用了四个字节，空了三个字节的内存地址，int数据从地址4开始。

此时，直接将地址4，5，6，7处的四个字节数据读取到即可。

第二种是没有内存对齐的情况

![image-20210509215718945](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210509215718945.png)

char型的数据和int型的数据挨在一起，该int数据从地址1开始，那么CPU想要读这个数据的话来看看需要几步操作：

1. 因为CPU是四个字节四个字节来寻址，首先CPU读取0，1，2，3处的四个字节数据
2. CPU读取4，5，6，7处的四个字节数据
3. 合并地址1，2，3，4处四个字节的数据才是本次操作需要的int数据

此时一共需要两次寻址，一次合并的操作。

虽然内存对齐会浪费内存资源，但事实上，相对于计算机来说，其内存资源一般都是充足的，人们更希望的是提高运行速度。