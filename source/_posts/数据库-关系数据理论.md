---
title: 数据库-关系数据理论
categories:
  - 学习之路
date: 2021-05-10 17:56:53
tags:
- 数据库
---

### 1.范式相关

#### 1.1 第一范式 1NF

**定义**：属于第一范式的关系，其所有属性都不可再分，即数据项不可分。

**理解**：第一范式强调数据表的原子性。

**规范化**：一个低一级的关系模式通过模式分解可以转化为若干个高一级的关系模式的集合，这个过程叫做规范化。

#### 1.2 第二范式 2NF

**定义**：在满足第一范式的基础上，每一个非主属性完全函数依赖于任何一个候选码。

**候选码**：若关系中的某一属性组能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系中有多个候选码，则选定其中一个为主码。

**主属性：** 所有候选码的属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。

**理解：** 第二范式是指每个表必须有一个（有且仅有一个）数据项作为关键字或主键（primary key），其他数据项与关键字或者主键一一对应，即**其他数据项完全依赖于关键字或主键**。由此可知单主属性的关系均属于第二范式。

#### 1.3 第三范式 3NF

**定义**：在满足第二范式的基础上，非主属性即不传递依赖于码，也不部分依赖于码。

**理解**：在第二范式的基础上，消除了传递依赖。

#### 1.4 BC范式 BCNF

**定义**：在满足第三范式的基础上，若每一个决定因素都包含码，则属于BC范式。

**理解**：消除了主属性对码的部分和传递函数依赖。

#### 1.5 第四范式 4NF

**定义**：限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。

**理解：** 显然一个关系模式是4NF，则必为BCNF。也就是说，当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值，若有多值就违反了4NF。

***

### 2.最小依赖集的求法

**第一步**：根据分解规则，把F中的函数依赖转化成右部都是单属性的函数依赖集合。

**第二步**：假设去掉F中的某个函数依赖，判断其是否冗余。

如：F={A->B, A->C, B->A, B->C, C->A}

首先判断A->B是否冗余，假设去掉A->B，则有G~1~={A->C, B->A, B->C, C->A}。A在G~1~中的闭包为(A)~G1~^+^=AC，不包括B，所以不冗余，不需要去掉。接下来对每个函数依赖采用相同的步骤。

**第三步**：对左边属性单一化，判断是否冗余。

如：CDE->B中，(CE)~F~^+^=CEBDGA,包含B，所以用CE->B代替CDE->B。

eg.

![image-20210510182232066](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210510182232066.png)

***

### 3.判断无损连接性

![image-20210510182345394](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210510182345394.png)

算法描述比较抽象，以下采用一种比较简单易懂的方法来处理这类问题。

eg.

1. ![image-20210510182655930](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210510182655930.png)
2. ![image-20210510182708555](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210510182708555.png)
3. ![image-20210510182719623](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210510182719623.png)
4. ![image-20210510182730707](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210510182730707.png)
5. ![image-20210510182742109](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210510182742109.png)
6. ![image-20210510182752781](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210510182752781.png)

此时发现第三行成为a~1~,a~2~,...,a~5~,算法终止，ρ具有无损连接性。

***

### 4.转换为3NF的保持函数依赖的分解

![image-20210510183053683](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210510183053683.png)

算法实现：

第一步：计算最小函数依赖集。

第二步：如果R中存在一些不在F中出现的属性，则将他们单独构成一个关系模式，并从模式R中消去。

第三步：如果F中有一个函数依赖X->A，且XA=R，则R不用分解，算法终止。

第四步：对F中的每一个函数依赖X->A，构造一个关系模式XA。如果X->A~1~,X->A~2~,...X->A~n~均属于F，则构造一个关系模式XA~1~A~2~...A~n~。

eg.

~~~bash
关系模式R<U,F>，其中U={C,T,H,R,S,G}，F={CS→G,C→T,TH→R,HR→C,HS→R}，将其分解成3NF并保持函数依赖。

1.由于R中的所有属性都在F中出现，所以转到下一步。
2.对F按具有相同左部的原则分为:
R1=CSG，R2=CT，R3=THR，R4=HRC，R5=HSR。
所以ρ={R1(CSG),R2(CT),R3(THR),R4(HRC),R5(HSR)}。
eg. C→T ,C→A是相同的左部，则将二者合并为一个关系C→AT
~~~



***

### 5.转换成3NF既有无损连接性又保持函数依赖的分解

![image-20210510183156711](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210510183156711.png)

算法实现：

第一步：得到3NF并保持函数依赖的分解(参考上一个标题),设结果为ρ={R~1~,R~2~,...,R~n~}。

第二步：求得关系模式R<U,F>的码X，令T=ρ∪{X}是R的一个分解。

第三步：求T的最小集合，即当R~i~≤R~j~∈T时，消去R~i~。

eg.

~~~bash
关系模式R<U,F>，其中：U={C,T,H,R,S,G}，F={CS→G,C→T,TH→R,HR→C,HS→R}，分解成3NF并保持无损连接和函数依赖。

1.根据上例，得到3NF并保持函数依赖的分解如下：
ρ={R1(CSG),R2(CT),R3(THR),R4(HRC),R5(HSR)}
2.易知HS是原模式的候选码,所以T={CSG,CT,HRT,CHR,HSR,HS}。由于HS是HSR的一个子集(消去小的),所以消去HS后的分解{CT,CSG,CHR,HSR,HRT}就是具有无损连接性和保持函数依赖性的分解,且其中每一个模式均为3NF。
~~~

**添码的目的是为了可以复原，即无损连接性。**

***

### 6.转换成BCNF的无损连接分解

![image-20210510183237895](https://ggssh.oss-cn-beijing.aliyuncs.com/mdimg/image-20210510183237895.png)

算法实现：

反复运用逐步分解定理，逐步分解关系模式R，使得每次分解都具有无损关联性，而且每次分解出来的子关系模式至少有一个是BCNF的。

第一步：置初值ρ={R<U,F>}。

第二步：检查ρ中的关系模式，如果均属于BCNF，则转到第四步。

第三步：在ρ中找出不属于BCNF的关系模式S，那么必有X->A∈F^+^，(A不包含于X)，且X不是S的关键字。因此XA必不包含S的全部属性，即XA是U~i~的真子集。把S分解为{S~1~，S~2~}，其中S~1~=XA，S~2~=(S-A)X，并以{S~1~,S~2~}代替ρ中的S，**返回第二步**。

第四步：算法终止，输出ρ。

eg.

~~~bash
关系模式R<U,F>，其中：U={A,B,C,D,E}，   F={A→C,C→D,B→C,DE→C,CE→A}，将其分解成BCNF并保持无损连接。

1.令ρ={R(U,F)}。

2.ρ中不是所有的模式都是BCNF，转入下一步。

3.
	分解R: R上的候选码为BE（因为所有函数依赖的右边没有BE——候选码确定算法）。考虑A→C函数依赖不满足BCNF条件（因A不包含候选码BE），将其分解成R1(AC)、R2(ABDE)（(U-C)(A)）。计算R1和R2的最小函数依赖集分别为：F1={A→C}，F2={B→D,DE→D,BE→A}。其中B→D是由于R2中没有属性C且B→C,C→D；DE→D是由于R2中没有属性C且DE→C,C→D；BE→A是由于R2中没有属性C且B→C,CE→A。又由于DE→D是蕴含关系，可以去掉，故F2={B→D,BE→A}。

	分解R2: R2上的候选关键字为BE。考虑B→D函数依赖不满足BCNF条件，将其分解成R21(BD)、R22(ABE)。计算R21和R22的最小函数依赖集分别为：F21={B→D}，F22={BE→A}。

	由于R22上的候选关键字为BE，而F22中的所有函数依赖满足BCNF条件。故R可以分解为无损连接性的BCNF如：ρ={R1(AC),R21(BD),R22(ABE)}

~~~



***

### 7.候选码确定算法

**候选码的两个性质**：

1. 决定性：X → U ∈F+
2. 最小性：不存在X’∈X，使得X’ → U ∈F+

**算法涉及到的两个推论**：

* 关系模式R(U,F)，若X是L类属性，且X^+^包含了R的全部属性，则X是R的唯一候选码。
* 关系模式R(U,F)，若X是L类、N类组成的属性集，且X^+^包含了R的全部属性，则X是R的唯一候选码。

**算法**：

第一步：将R的所有属性分为L，R，N和LR四类，令X为L、N类属性的结合，Y为LR类属性的集合。

* L类: 仅出现在F的函数依赖左部的属性；
* R类: 仅出现在F的函数依赖右部的属性；
* N类: 在F的函数依赖左右两边都不出现的属性；
* LR类:在F的函数依赖左右两边都出现的属性 。

第二步：若X~F~^+^=U，则X为R的唯一候选码，结束；否则转到第三步。(记住是F中的闭包，要与**求最小函数依赖集中求闭包的过程不同**)。

第三步：逐一取Y中的**单一属性A**，若(XA)~F~^+^=U，则XA为候选码，令Y=Y-{A}，转到第四步。

第四步：若已找出所有候选码，则转到第五步，否则再依次取Y中的任意两个、三个……属性，与X组成属性组XZ，若(XZ)~F~^+^=U,且XZ不包含已求得的候选码，则XZ为候选码。

第五步：算法结束，输出结果。

eg.

~~~bash
设关系模式R(S, D, I, B, O, Q), 其函数依赖集:
 F = { S→D, I→B, B→O, O→Q, Q→I }，求R的所有候选码。
 解: L类(S);  R类(D)  ; N类(无) ;  LR类(I, B, O, Q)
 因为S+=SD, 所以S不是R的候选码；
 因为(SI)+=SIDBOQ，所以SI是一个候选码；
 因为(SB)+=SBDOQI，所以SB也是一个候选码；
 因为(SO)+=SODQIB，所以SO也是一个候选码；
 因为(SQ)+=SQDIBO，所以SQ也是一个候选码。
~~~

